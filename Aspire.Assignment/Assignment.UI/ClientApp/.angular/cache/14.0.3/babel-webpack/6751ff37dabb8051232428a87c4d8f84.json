{"ast":null,"code":"import _asyncToGenerator from \"D:/Assignment/Aspire.Assignment/Assignment.UI/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { AsyncSubject, isObservable, ReplaySubject } from 'rxjs';\nimport { GoogleLoginProvider } from './providers/google-login-provider';\nimport * as i0 from \"@angular/core\";\n/**\r\n * The service encapsulating the social login functionality. Exposes methods like\r\n * `signIn`, `signOut`. Also, exposes an `authState` `Observable` that one can\r\n * subscribe to get the current logged in user information.\r\n *\r\n * @dynamic\r\n */\n\nexport class SocialAuthService {\n  /**\r\n   * @param config A `SocialAuthServiceConfig` object or a `Promise` that resolves to a `SocialAuthServiceConfig` object\r\n   */\n  constructor(config, _ngZone, _injector) {\n    this._ngZone = _ngZone;\n    this._injector = _injector;\n    this.providers = new Map();\n    this.autoLogin = false;\n    this._user = null;\n    this._authState = new ReplaySubject(1);\n    /* Consider making this an enum comprising LOADING, LOADED, FAILED etc. */\n\n    this.initialized = false;\n    this._initState = new AsyncSubject();\n\n    if (config instanceof Promise) {\n      config.then(config => {\n        this.initialize(config);\n      });\n    } else {\n      this.initialize(config);\n    }\n  }\n  /** An `Observable` that one can subscribe to get the current logged in user information */\n\n\n  get authState() {\n    return this._authState.asObservable();\n  }\n  /** An `Observable` to communicate the readiness of the service and associated login providers */\n\n\n  get initState() {\n    return this._initState.asObservable();\n  }\n\n  initialize(config) {\n    this.autoLogin = config.autoLogin !== undefined ? config.autoLogin : false;\n    const {\n      onError = console.error\n    } = config;\n    config.providers.forEach(item => {\n      this.providers.set(item.id, 'prototype' in item.provider ? this._injector.get(item.provider) : item.provider);\n    });\n    Promise.all(Array.from(this.providers.values()).map(provider => provider.initialize(this.autoLogin))).then(() => {\n      if (this.autoLogin) {\n        const loginStatusPromises = [];\n        let loggedIn = false;\n        this.providers.forEach((provider, key) => {\n          const promise = provider.getLoginStatus();\n          loginStatusPromises.push(promise);\n          promise.then(user => {\n            this.setUser(user, key);\n            loggedIn = true;\n          }).catch(console.debug);\n        });\n        Promise.all(loginStatusPromises).catch(() => {\n          if (!loggedIn) {\n            this._user = null;\n\n            this._authState.next(null);\n          }\n        });\n      }\n\n      this.providers.forEach((provider, key) => {\n        if (isObservable(provider.changeUser)) {\n          provider.changeUser.subscribe(user => {\n            this._ngZone.run(() => {\n              this.setUser(user, key);\n            });\n          });\n        }\n      });\n    }).catch(error => {\n      onError(error);\n    }).finally(() => {\n      this.initialized = true;\n\n      this._initState.next(this.initialized);\n\n      this._initState.complete();\n    });\n  }\n\n  getAccessToken(providerId) {\n    var _this = this;\n\n    return _asyncToGenerator(function* () {\n      const providerObject = _this.providers.get(providerId);\n\n      if (!_this.initialized) {\n        throw SocialAuthService.ERR_NOT_INITIALIZED;\n      } else if (!providerObject) {\n        throw SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND;\n      } else if (!(providerObject instanceof GoogleLoginProvider)) {\n        throw SocialAuthService.ERR_NOT_SUPPORTED_FOR_ACCESS_TOKEN;\n      }\n\n      return yield providerObject.getAccessToken();\n    })();\n  }\n\n  refreshAuthToken(providerId) {\n    return new Promise((resolve, reject) => {\n      if (!this.initialized) {\n        reject(SocialAuthService.ERR_NOT_INITIALIZED);\n      } else {\n        const providerObject = this.providers.get(providerId);\n\n        if (providerObject) {\n          if (typeof providerObject.refreshToken !== 'function') {\n            reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);\n          } else {\n            providerObject.refreshToken().then(user => {\n              this.setUser(user, providerId);\n              resolve();\n            }).catch(err => {\n              reject(err);\n            });\n          }\n        } else {\n          reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);\n        }\n      }\n    });\n  }\n\n  refreshAccessToken(providerId) {\n    return new Promise((resolve, reject) => {\n      if (!this.initialized) {\n        reject(SocialAuthService.ERR_NOT_INITIALIZED);\n      } else if (providerId !== GoogleLoginProvider.PROVIDER_ID) {\n        reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);\n      } else {\n        const providerObject = this.providers.get(providerId);\n\n        if (providerObject instanceof GoogleLoginProvider) {\n          providerObject.revokeAccessToken().then(resolve).catch(reject);\n        } else {\n          reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);\n        }\n      }\n    });\n  }\n  /**\r\n   * A method used to sign in a user with a specific `LoginProvider`.\r\n   *\r\n   * @param providerId Id with which the `LoginProvider` has been registered with the service\r\n   * @param signInOptions Optional `LoginProvider` specific arguments\r\n   * @returns A `Promise` that resolves to the authenticated user information\r\n   */\n\n\n  signIn(providerId, signInOptions) {\n    return new Promise((resolve, reject) => {\n      if (!this.initialized) {\n        reject(SocialAuthService.ERR_NOT_INITIALIZED);\n      } else {\n        let providerObject = this.providers.get(providerId);\n\n        if (providerObject) {\n          providerObject.signIn(signInOptions).then(user => {\n            this.setUser(user, providerId);\n            resolve(user);\n          }).catch(err => {\n            reject(err);\n          });\n        } else {\n          reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);\n        }\n      }\n    });\n  }\n  /**\r\n   * A method used to sign out the currently loggen in user.\r\n   *\r\n   * @param revoke Optional parameter to specify whether a hard sign out is to be performed\r\n   * @returns A `Promise` that resolves if the operation is successful, rejects otherwise\r\n   */\n\n\n  signOut(revoke = false) {\n    return new Promise((resolve, reject) => {\n      if (!this.initialized) {\n        reject(SocialAuthService.ERR_NOT_INITIALIZED);\n      } else if (!this._user) {\n        reject(SocialAuthService.ERR_NOT_LOGGED_IN);\n      } else {\n        let providerId = this._user.provider;\n        let providerObject = this.providers.get(providerId);\n\n        if (providerObject) {\n          providerObject.signOut(revoke).then(() => {\n            resolve();\n            this.setUser(null);\n          }).catch(err => {\n            reject(err);\n          });\n        } else {\n          reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);\n        }\n      }\n    });\n  }\n\n  setUser(user, id) {\n    if (user && id) user.provider = id;\n    this._user = user;\n\n    this._authState.next(user);\n  }\n\n}\nSocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND = 'Login provider not found';\nSocialAuthService.ERR_NOT_LOGGED_IN = 'Not logged in';\nSocialAuthService.ERR_NOT_INITIALIZED = 'Login providers not ready yet. Are there errors on your console?';\nSocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN = 'Chosen login provider is not supported for refreshing a token';\nSocialAuthService.ERR_NOT_SUPPORTED_FOR_ACCESS_TOKEN = 'Chosen login provider is not supported for getting an access token';\n\nSocialAuthService.ɵfac = function SocialAuthService_Factory(t) {\n  return new (t || SocialAuthService)(i0.ɵɵinject('SocialAuthServiceConfig'), i0.ɵɵinject(i0.NgZone), i0.ɵɵinject(i0.Injector));\n};\n\nSocialAuthService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: SocialAuthService,\n  factory: SocialAuthService.ɵfac,\n  providedIn: 'root'\n});","map":{"version":3,"mappings":";AACA,SAASA,YAAT,EAAuBC,YAAvB,EAAiDC,aAAjD,QAAsE,MAAtE;AAGA,SAASC,mBAAT,QAAoC,mCAApC;;AAWA;;;;;;;;AAQA,OAAM,MAAOC,iBAAP,CAAwB;EA+B5B;;;EAGAC,YAEEC,MAFF,EAGmBC,OAHnB,EAImBC,SAJnB,EAIsC;IADnB;IACA;IA3BX,iBAAwC,IAAIC,GAAJ,EAAxC;IACA,iBAAY,KAAZ;IAEA,aAA2B,IAA3B;IACA,kBAA+C,IAAIP,aAAJ,CAAkB,CAAlB,CAA/C;IAER;;IACQ,mBAAc,KAAd;IACA,kBAAoC,IAAIF,YAAJ,EAApC;;IAqBN,IAAIM,MAAM,YAAYI,OAAtB,EAA+B;MAC7BJ,MAAM,CAACK,IAAP,CAAaL,MAAD,IAAoC;QAC9C,KAAKM,UAAL,CAAgBN,MAAhB;MACD,CAFD;IAGD,CAJD,MAIO;MACL,KAAKM,UAAL,CAAgBN,MAAhB;IACD;EACF;EA1BD;;;EACa,IAATO,SAAS;IACX,OAAO,KAAKC,UAAL,CAAgBC,YAAhB,EAAP;EACD;EAED;;;EACa,IAATC,SAAS;IACX,OAAO,KAAKC,UAAL,CAAgBF,YAAhB,EAAP;EACD;;EAoBOH,UAAU,CAACN,MAAD,EAAgC;IAChD,KAAKY,SAAL,GAAiBZ,MAAM,CAACY,SAAP,KAAqBC,SAArB,GAAiCb,MAAM,CAACY,SAAxC,GAAoD,KAArE;IACA,MAAM;MAAEE,OAAO,GAAGC,OAAO,CAACC;IAApB,IAA8BhB,MAApC;IAEAA,MAAM,CAACiB,SAAP,CAAiBC,OAAjB,CAA0BC,IAAD,IAAS;MAChC,KAAKF,SAAL,CAAeG,GAAf,CACED,IAAI,CAACE,EADP,EAEE,eAAeF,IAAI,CAACG,QAApB,GACI,KAAKpB,SAAL,CAAeqB,GAAf,CAAmBJ,IAAI,CAACG,QAAxB,CADJ,GAEIH,IAAI,CAACG,QAJX;IAMD,CAPD;IASAlB,OAAO,CAACoB,GAAR,CACEC,KAAK,CAACC,IAAN,CAAW,KAAKT,SAAL,CAAeU,MAAf,EAAX,EAAoCC,GAApC,CAAyCN,QAAD,IACtCA,QAAQ,CAAChB,UAAT,CAAoB,KAAKM,SAAzB,CADF,CADF,EAKGP,IALH,CAKQ,MAAK;MACT,IAAI,KAAKO,SAAT,EAAoB;QAClB,MAAMiB,mBAAmB,GAAG,EAA5B;QACA,IAAIC,QAAQ,GAAG,KAAf;QAEA,KAAKb,SAAL,CAAeC,OAAf,CAAuB,CAACI,QAAD,EAA0BS,GAA1B,KAAyC;UAC9D,MAAMC,OAAO,GAAGV,QAAQ,CAACW,cAAT,EAAhB;UACAJ,mBAAmB,CAACK,IAApB,CAAyBF,OAAzB;UACAA,OAAO,CACJ3B,IADH,CACS8B,IAAD,IAAqB;YACzB,KAAKC,OAAL,CAAaD,IAAb,EAAmBJ,GAAnB;YACAD,QAAQ,GAAG,IAAX;UACD,CAJH,EAKGO,KALH,CAKStB,OAAO,CAACuB,KALjB;QAMD,CATD;QAUAlC,OAAO,CAACoB,GAAR,CAAYK,mBAAZ,EAAiCQ,KAAjC,CAAuC,MAAK;UAC1C,IAAI,CAACP,QAAL,EAAe;YACb,KAAKS,KAAL,GAAa,IAAb;;YACA,KAAK/B,UAAL,CAAgBgC,IAAhB,CAAqB,IAArB;UACD;QACF,CALD;MAMD;;MAED,KAAKvB,SAAL,CAAeC,OAAf,CAAuB,CAACI,QAAD,EAAWS,GAAX,KAAkB;QACvC,IAAIpC,YAAY,CAAC2B,QAAQ,CAACmB,UAAV,CAAhB,EAAuC;UACrCnB,QAAQ,CAACmB,UAAT,CAAoBC,SAApB,CAA+BP,IAAD,IAAS;YACrC,KAAKlC,OAAL,CAAa0C,GAAb,CAAiB,MAAK;cACpB,KAAKP,OAAL,CAAaD,IAAb,EAAmBJ,GAAnB;YACD,CAFD;UAGD,CAJD;QAKD;MACF,CARD;IASD,CArCH,EAsCGM,KAtCH,CAsCUrB,KAAD,IAAU;MACfF,OAAO,CAACE,KAAD,CAAP;IACD,CAxCH,EAyCG4B,OAzCH,CAyCW,MAAK;MACZ,KAAKC,WAAL,GAAmB,IAAnB;;MACA,KAAKlC,UAAL,CAAgB6B,IAAhB,CAAqB,KAAKK,WAA1B;;MACA,KAAKlC,UAAL,CAAgBmC,QAAhB;IACD,CA7CH;EA8CD;;EAEKC,cAAc,CAACC,UAAD,EAAmB;IAAA;;IAAA;MACrC,MAAMC,cAAc,GAAG,KAAI,CAAChC,SAAL,CAAeM,GAAf,CAAmByB,UAAnB,CAAvB;;MACA,IAAI,CAAC,KAAI,CAACH,WAAV,EAAuB;QACrB,MAAM/C,iBAAiB,CAACoD,mBAAxB;MACD,CAFD,MAEO,IAAI,CAACD,cAAL,EAAqB;QAC1B,MAAMnD,iBAAiB,CAACqD,4BAAxB;MACD,CAFM,MAEA,IAAI,EAAEF,cAAc,YAAYpD,mBAA5B,CAAJ,EAAsD;QAC3D,MAAMC,iBAAiB,CAACsD,kCAAxB;MACD;;MAED,aAAaH,cAAc,CAACF,cAAf,EAAb;IAVqC;EAWtC;;EAEDM,gBAAgB,CAACL,UAAD,EAAmB;IACjC,OAAO,IAAI5C,OAAJ,CAAY,CAACkD,OAAD,EAAUC,MAAV,KAAoB;MACrC,IAAI,CAAC,KAAKV,WAAV,EAAuB;QACrBU,MAAM,CAACzD,iBAAiB,CAACoD,mBAAnB,CAAN;MACD,CAFD,MAEO;QACL,MAAMD,cAAc,GAAG,KAAKhC,SAAL,CAAeM,GAAf,CAAmByB,UAAnB,CAAvB;;QACA,IAAIC,cAAJ,EAAoB;UAClB,IAAI,OAAOA,cAAc,CAACO,YAAtB,KAAuC,UAA3C,EAAuD;YACrDD,MAAM,CAACzD,iBAAiB,CAAC2D,mCAAnB,CAAN;UACD,CAFD,MAEO;YACLR,cAAc,CACXO,YADH,GAEGnD,IAFH,CAES8B,IAAD,IAAS;cACb,KAAKC,OAAL,CAAaD,IAAb,EAAmBa,UAAnB;cACAM,OAAO;YACR,CALH,EAMGjB,KANH,CAMUqB,GAAD,IAAQ;cACbH,MAAM,CAACG,GAAD,CAAN;YACD,CARH;UASD;QACF,CAdD,MAcO;UACLH,MAAM,CAACzD,iBAAiB,CAACqD,4BAAnB,CAAN;QACD;MACF;IACF,CAvBM,CAAP;EAwBD;;EAEDQ,kBAAkB,CAACX,UAAD,EAAmB;IACnC,OAAO,IAAI5C,OAAJ,CAAY,CAACkD,OAAD,EAAUC,MAAV,KAAoB;MACrC,IAAI,CAAC,KAAKV,WAAV,EAAuB;QACrBU,MAAM,CAACzD,iBAAiB,CAACoD,mBAAnB,CAAN;MACD,CAFD,MAEO,IAAIF,UAAU,KAAKnD,mBAAmB,CAAC+D,WAAvC,EAAoD;QACzDL,MAAM,CAACzD,iBAAiB,CAAC2D,mCAAnB,CAAN;MACD,CAFM,MAEA;QACL,MAAMR,cAAc,GAAG,KAAKhC,SAAL,CAAeM,GAAf,CAAmByB,UAAnB,CAAvB;;QACA,IAAIC,cAAc,YAAYpD,mBAA9B,EAAmD;UACjDoD,cAAc,CAACY,iBAAf,GAAmCxD,IAAnC,CAAwCiD,OAAxC,EAAiDjB,KAAjD,CAAuDkB,MAAvD;QACD,CAFD,MAEO;UACLA,MAAM,CAACzD,iBAAiB,CAACqD,4BAAnB,CAAN;QACD;MACF;IACF,CAbM,CAAP;EAcD;EAED;;;;;;;;;EAOAW,MAAM,CAACd,UAAD,EAAqBe,aAArB,EAAwC;IAC5C,OAAO,IAAI3D,OAAJ,CAAY,CAACkD,OAAD,EAAUC,MAAV,KAAoB;MACrC,IAAI,CAAC,KAAKV,WAAV,EAAuB;QACrBU,MAAM,CAACzD,iBAAiB,CAACoD,mBAAnB,CAAN;MACD,CAFD,MAEO;QACL,IAAID,cAAc,GAAG,KAAKhC,SAAL,CAAeM,GAAf,CAAmByB,UAAnB,CAArB;;QACA,IAAIC,cAAJ,EAAoB;UAClBA,cAAc,CACXa,MADH,CACUC,aADV,EAEG1D,IAFH,CAES8B,IAAD,IAAqB;YACzB,KAAKC,OAAL,CAAaD,IAAb,EAAmBa,UAAnB;YACAM,OAAO,CAACnB,IAAD,CAAP;UACD,CALH,EAMGE,KANH,CAMUqB,GAAD,IAAQ;YACbH,MAAM,CAACG,GAAD,CAAN;UACD,CARH;QASD,CAVD,MAUO;UACLH,MAAM,CAACzD,iBAAiB,CAACqD,4BAAnB,CAAN;QACD;MACF;IACF,CAnBM,CAAP;EAoBD;EAED;;;;;;;;EAMAa,OAAO,CAACC,SAAkB,KAAnB,EAAwB;IAC7B,OAAO,IAAI7D,OAAJ,CAAY,CAACkD,OAAD,EAAUC,MAAV,KAAoB;MACrC,IAAI,CAAC,KAAKV,WAAV,EAAuB;QACrBU,MAAM,CAACzD,iBAAiB,CAACoD,mBAAnB,CAAN;MACD,CAFD,MAEO,IAAI,CAAC,KAAKX,KAAV,EAAiB;QACtBgB,MAAM,CAACzD,iBAAiB,CAACoE,iBAAnB,CAAN;MACD,CAFM,MAEA;QACL,IAAIlB,UAAU,GAAG,KAAKT,KAAL,CAAWjB,QAA5B;QACA,IAAI2B,cAAc,GAAG,KAAKhC,SAAL,CAAeM,GAAf,CAAmByB,UAAnB,CAArB;;QACA,IAAIC,cAAJ,EAAoB;UAClBA,cAAc,CACXe,OADH,CACWC,MADX,EAEG5D,IAFH,CAEQ,MAAK;YACTiD,OAAO;YACP,KAAKlB,OAAL,CAAa,IAAb;UACD,CALH,EAMGC,KANH,CAMUqB,GAAD,IAAQ;YACbH,MAAM,CAACG,GAAD,CAAN;UACD,CARH;QASD,CAVD,MAUO;UACLH,MAAM,CAACzD,iBAAiB,CAACqD,4BAAnB,CAAN;QACD;MACF;IACF,CAtBM,CAAP;EAuBD;;EAEOf,OAAO,CAACD,IAAD,EAA0Bd,EAA1B,EAAqC;IAClD,IAAIc,IAAI,IAAId,EAAZ,EAAgBc,IAAI,CAACb,QAAL,GAAgBD,EAAhB;IAChB,KAAKkB,KAAL,GAAaJ,IAAb;;IACA,KAAK3B,UAAL,CAAgBgC,IAAhB,CAAqBL,IAArB;EACD;;AAzO2B;AACJrC,iDACtB,0BADsB;AAEAA,sCAAoB,eAApB;AACAA,wCACtB,kEADsB;AAEAA,wDACtB,+DADsB;AAEAA,uDACtB,oEADsB;;;mBARbA,mBAAiBqE,YAmClB,yBAnCkB,GAmCOA;AAAA;;;SAnCxBrE;EAAiBsE,SAAjBtE,iBAAiB;EAAAuE,YADJ","names":["AsyncSubject","isObservable","ReplaySubject","GoogleLoginProvider","SocialAuthService","constructor","config","_ngZone","_injector","Map","Promise","then","initialize","authState","_authState","asObservable","initState","_initState","autoLogin","undefined","onError","console","error","providers","forEach","item","set","id","provider","get","all","Array","from","values","map","loginStatusPromises","loggedIn","key","promise","getLoginStatus","push","user","setUser","catch","debug","_user","next","changeUser","subscribe","run","finally","initialized","complete","getAccessToken","providerId","providerObject","ERR_NOT_INITIALIZED","ERR_LOGIN_PROVIDER_NOT_FOUND","ERR_NOT_SUPPORTED_FOR_ACCESS_TOKEN","refreshAuthToken","resolve","reject","refreshToken","ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN","err","refreshAccessToken","PROVIDER_ID","revokeAccessToken","signIn","signInOptions","signOut","revoke","ERR_NOT_LOGGED_IN","i0","factory","providedIn"],"sourceRoot":"","sources":["D:\\Assignment\\Aspire.Assignment\\Assignment.UI\\ClientApp\\projects\\lib\\src\\socialauth.service.ts"],"sourcesContent":["import { Inject, Injectable, Injector, NgZone, Type } from '@angular/core';\r\nimport { AsyncSubject, isObservable, Observable, ReplaySubject } from 'rxjs';\r\nimport { LoginProvider } from './entities/login-provider';\r\nimport { SocialUser } from './entities/social-user';\r\nimport { GoogleLoginProvider } from './providers/google-login-provider';\r\n\r\n/**\r\n * An interface to define the shape of the service configuration options.\r\n */\r\nexport interface SocialAuthServiceConfig {\r\n  autoLogin?: boolean;\r\n  providers: { id: string; provider: LoginProvider | Type<LoginProvider> }[];\r\n  onError?: (error: any) => any;\r\n}\r\n\r\n/**\r\n * The service encapsulating the social login functionality. Exposes methods like\r\n * `signIn`, `signOut`. Also, exposes an `authState` `Observable` that one can\r\n * subscribe to get the current logged in user information.\r\n *\r\n * @dynamic\r\n */\r\n@Injectable({ providedIn: 'root' })\r\nexport class SocialAuthService {\r\n  private static readonly ERR_LOGIN_PROVIDER_NOT_FOUND =\r\n    'Login provider not found';\r\n  private static readonly ERR_NOT_LOGGED_IN = 'Not logged in';\r\n  private static readonly ERR_NOT_INITIALIZED =\r\n    'Login providers not ready yet. Are there errors on your console?';\r\n  private static readonly ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN =\r\n    'Chosen login provider is not supported for refreshing a token';\r\n  private static readonly ERR_NOT_SUPPORTED_FOR_ACCESS_TOKEN =\r\n    'Chosen login provider is not supported for getting an access token';\r\n\r\n  private providers: Map<string, LoginProvider> = new Map();\r\n  private autoLogin = false;\r\n\r\n  private _user: SocialUser | null = null;\r\n  private _authState: ReplaySubject<SocialUser | null> = new ReplaySubject(1);\r\n\r\n  /* Consider making this an enum comprising LOADING, LOADED, FAILED etc. */\r\n  private initialized = false;\r\n  private _initState: AsyncSubject<boolean> = new AsyncSubject();\r\n\r\n  /** An `Observable` that one can subscribe to get the current logged in user information */\r\n  get authState(): Observable<SocialUser> {\r\n    return this._authState.asObservable();\r\n  }\r\n\r\n  /** An `Observable` to communicate the readiness of the service and associated login providers */\r\n  get initState(): Observable<boolean> {\r\n    return this._initState.asObservable();\r\n  }\r\n\r\n  /**\r\n   * @param config A `SocialAuthServiceConfig` object or a `Promise` that resolves to a `SocialAuthServiceConfig` object\r\n   */\r\n  constructor(\r\n    @Inject('SocialAuthServiceConfig')\r\n    config: SocialAuthServiceConfig | Promise<SocialAuthServiceConfig>,\r\n    private readonly _ngZone: NgZone,\r\n    private readonly _injector: Injector\r\n  ) {\r\n    if (config instanceof Promise) {\r\n      config.then((config: SocialAuthServiceConfig) => {\r\n        this.initialize(config);\r\n      });\r\n    } else {\r\n      this.initialize(config);\r\n    }\r\n  }\r\n\r\n  private initialize(config: SocialAuthServiceConfig) {\r\n    this.autoLogin = config.autoLogin !== undefined ? config.autoLogin : false;\r\n    const { onError = console.error } = config;\r\n\r\n    config.providers.forEach((item) => {\r\n      this.providers.set(\r\n        item.id,\r\n        'prototype' in item.provider\r\n          ? this._injector.get(item.provider)\r\n          : item.provider\r\n      );\r\n    });\r\n\r\n    Promise.all(\r\n      Array.from(this.providers.values()).map((provider) =>\r\n        provider.initialize(this.autoLogin)\r\n      )\r\n    )\r\n      .then(() => {\r\n        if (this.autoLogin) {\r\n          const loginStatusPromises = [];\r\n          let loggedIn = false;\r\n\r\n          this.providers.forEach((provider: LoginProvider, key: string) => {\r\n            const promise = provider.getLoginStatus();\r\n            loginStatusPromises.push(promise);\r\n            promise\r\n              .then((user: SocialUser) => {\r\n                this.setUser(user, key);\r\n                loggedIn = true;\r\n              })\r\n              .catch(console.debug);\r\n          });\r\n          Promise.all(loginStatusPromises).catch(() => {\r\n            if (!loggedIn) {\r\n              this._user = null;\r\n              this._authState.next(null);\r\n            }\r\n          });\r\n        }\r\n\r\n        this.providers.forEach((provider, key) => {\r\n          if (isObservable(provider.changeUser)) {\r\n            provider.changeUser.subscribe((user) => {\r\n              this._ngZone.run(() => {\r\n                this.setUser(user, key);\r\n              });\r\n            });\r\n          }\r\n        });\r\n      })\r\n      .catch((error) => {\r\n        onError(error);\r\n      })\r\n      .finally(() => {\r\n        this.initialized = true;\r\n        this._initState.next(this.initialized);\r\n        this._initState.complete();\r\n      });\r\n  }\r\n\r\n  async getAccessToken(providerId: string): Promise<string> {\r\n    const providerObject = this.providers.get(providerId);\r\n    if (!this.initialized) {\r\n      throw SocialAuthService.ERR_NOT_INITIALIZED;\r\n    } else if (!providerObject) {\r\n      throw SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND;\r\n    } else if (!(providerObject instanceof GoogleLoginProvider)) {\r\n      throw SocialAuthService.ERR_NOT_SUPPORTED_FOR_ACCESS_TOKEN;\r\n    }\r\n\r\n    return await providerObject.getAccessToken();\r\n  }\r\n\r\n  refreshAuthToken(providerId: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.initialized) {\r\n        reject(SocialAuthService.ERR_NOT_INITIALIZED);\r\n      } else {\r\n        const providerObject = this.providers.get(providerId);\r\n        if (providerObject) {\r\n          if (typeof providerObject.refreshToken !== 'function') {\r\n            reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);\r\n          } else {\r\n            providerObject\r\n              .refreshToken()\r\n              .then((user) => {\r\n                this.setUser(user, providerId);\r\n                resolve();\r\n              })\r\n              .catch((err) => {\r\n                reject(err);\r\n              });\r\n          }\r\n        } else {\r\n          reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  refreshAccessToken(providerId: string): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.initialized) {\r\n        reject(SocialAuthService.ERR_NOT_INITIALIZED);\r\n      } else if (providerId !== GoogleLoginProvider.PROVIDER_ID) {\r\n        reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);\r\n      } else {\r\n        const providerObject = this.providers.get(providerId);\r\n        if (providerObject instanceof GoogleLoginProvider) {\r\n          providerObject.revokeAccessToken().then(resolve).catch(reject);\r\n        } else {\r\n          reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * A method used to sign in a user with a specific `LoginProvider`.\r\n   *\r\n   * @param providerId Id with which the `LoginProvider` has been registered with the service\r\n   * @param signInOptions Optional `LoginProvider` specific arguments\r\n   * @returns A `Promise` that resolves to the authenticated user information\r\n   */\r\n  signIn(providerId: string, signInOptions?: any): Promise<SocialUser> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.initialized) {\r\n        reject(SocialAuthService.ERR_NOT_INITIALIZED);\r\n      } else {\r\n        let providerObject = this.providers.get(providerId);\r\n        if (providerObject) {\r\n          providerObject\r\n            .signIn(signInOptions)\r\n            .then((user: SocialUser) => {\r\n              this.setUser(user, providerId);\r\n              resolve(user);\r\n            })\r\n            .catch((err) => {\r\n              reject(err);\r\n            });\r\n        } else {\r\n          reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * A method used to sign out the currently loggen in user.\r\n   *\r\n   * @param revoke Optional parameter to specify whether a hard sign out is to be performed\r\n   * @returns A `Promise` that resolves if the operation is successful, rejects otherwise\r\n   */\r\n  signOut(revoke: boolean = false): Promise<void> {\r\n    return new Promise((resolve, reject) => {\r\n      if (!this.initialized) {\r\n        reject(SocialAuthService.ERR_NOT_INITIALIZED);\r\n      } else if (!this._user) {\r\n        reject(SocialAuthService.ERR_NOT_LOGGED_IN);\r\n      } else {\r\n        let providerId = this._user.provider;\r\n        let providerObject = this.providers.get(providerId);\r\n        if (providerObject) {\r\n          providerObject\r\n            .signOut(revoke)\r\n            .then(() => {\r\n              resolve();\r\n              this.setUser(null);\r\n            })\r\n            .catch((err) => {\r\n              reject(err);\r\n            });\r\n        } else {\r\n          reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);\r\n        }\r\n      }\r\n    });\r\n  }\r\n\r\n  private setUser(user: SocialUser | null, id?: string) {\r\n    if (user && id) user.provider = id;\r\n    this._user = user;\r\n    this._authState.next(user);\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}